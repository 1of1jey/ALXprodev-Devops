#!/bin/bash

# Parallel Pokémon Data Fetcher
# Fetches data for multiple Pokémon in parallel using background processes
# Includes proper process management and error handling

API_BASE_URL="https://pokeapi.co/api/v2/pokemon"
OUTPUT_DIR="pokemon_data"
ERROR_FILE="errors.txt"
MAX_RETRIES=3
RETRY_DELAY=2

# List of Pokémon to fetch
POKEMON_LIST=("bulbasaur" "ivysaur" "venusaur" "charmander" "charmeleon")

# Array to store background process IDs
declare -a PIDS

# Create output directory if it doesn't exist
mkdir -p "$OUTPUT_DIR"

# Function to fetch a single Pokémon with retry logic
fetch_pokemon() {
    local pokemon="$1"
    local attempt=1
    
    while [ $attempt -le $MAX_RETRIES ]; do
        # Make API request and capture HTTP status code
        HTTP_RESPONSE=$(curl -s -w "\n%{http_code}" --connect-timeout 10 --max-time 30 "$API_BASE_URL/$pokemon" 2>&1)
        
        # Check if curl command succeeded
        if [ $? -ne 0 ]; then
            if [ $attempt -lt $MAX_RETRIES ]; then
                sleep $RETRY_DELAY
                ((attempt++))
                continue
            else
                TIMESTAMP=$(date '+%Y-%m-%d %H:%M:%S')
                echo "[$TIMESTAMP] Error: Network failure after $MAX_RETRIES attempts for $pokemon" >> "$ERROR_FILE"
                echo "Error: Network failure for $pokemon after $MAX_RETRIES attempts"
                return 1
            fi
        fi
        
        # Extract HTTP status code (last line)
        HTTP_CODE=$(echo "$HTTP_RESPONSE" | tail -n 1)
        
        # Extract response body (everything except last line)
        RESPONSE_BODY=$(echo "$HTTP_RESPONSE" | sed '$d')
        
        # Check if request was successful (HTTP 200)
        if [ "$HTTP_CODE" -eq 200 ]; then
            OUTPUT_FILE="$OUTPUT_DIR/${pokemon}.json"
            echo "$RESPONSE_BODY" > "$OUTPUT_FILE"
            echo "Saved data to $OUTPUT_FILE"
            return 0
        elif [ "$HTTP_CODE" -eq 404 ]; then
            # Invalid Pokémon name - don't retry
            TIMESTAMP=$(date '+%Y-%m-%d %H:%M:%S')
            echo "[$TIMESTAMP] Error: HTTP 404 - Invalid Pokémon name: $pokemon" >> "$ERROR_FILE"
            echo "Error: Invalid Pokémon name '$pokemon' (HTTP 404)"
            return 1
        else
            # Other HTTP errors - retry
            if [ $attempt -lt $MAX_RETRIES ]; then
                sleep $RETRY_DELAY
                ((attempt++))
                continue
            else
                TIMESTAMP=$(date '+%Y-%m-%d %H:%M:%S')
                echo "[$TIMESTAMP] Error: HTTP $HTTP_CODE after $MAX_RETRIES attempts for $pokemon" >> "$ERROR_FILE"
                echo "Error: Request failed with HTTP code $HTTP_CODE for $pokemon"
                return 1
            fi
        fi
    done
}

# Start timestamp
START_TIME=$(date +%s)

echo "Starting parallel fetch for ${#POKEMON_LIST[@]} Pokémon..."
echo ""

# Launch fetch operations in parallel
for pokemon in "${POKEMON_LIST[@]}"; do
    # Convert to lowercase for API request
    pokemon_lower=$(echo "$pokemon" | tr '[:upper:]' '[:lower:]')
    
    echo "Fetching data for $pokemon_lower..."
    
    # Run fetch in background and store PID
    fetch_pokemon "$pokemon_lower" &
    PIDS+=($!)
done

echo ""
echo "All fetch processes launched. Waiting for completion..."
echo ""

# Display active background jobs
echo "Active background jobs:"
jobs
echo ""

# Wait for all background processes to complete
SUCCESS_COUNT=0
FAIL_COUNT=0

for pid in "${PIDS[@]}"; do
    # Wait for each process and capture exit status
    wait $pid
    EXIT_STATUS=$?
    
    if [ $EXIT_STATUS -eq 0 ]; then
        ((SUCCESS_COUNT++))
    else
        ((FAIL_COUNT++))
    fi
done

# Verify all jobs are complete
echo "Remaining jobs after completion:"
jobs

# End timestamp and calculate duration
END_TIME=$(date +%s)
DURATION=$((END_TIME - START_TIME))


# Exit with error if any fetches failed
if [ $FAIL_COUNT -gt 0 ]; then
    echo "Some fetches failed. Check $ERROR_FILE for details."
    exit 1
fi

# Cleanup function to kill all background processes on script exit
cleanup() {
    echo ""
    echo "Cleaning up background processes..."
    for pid in "${PIDS[@]}"; do
        if kill -0 $pid 2>/dev/null; then
            echo "Killing process $pid"
            kill $pid 2>/dev/null
        fi
    done
}

# Set trap to call cleanup on script exit or interruption
trap cleanup EXIT INT TERM
