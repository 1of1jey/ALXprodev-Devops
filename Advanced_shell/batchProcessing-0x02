#!/bin/bash

# Batch Pokémon Data Fetcher with Error Handling and Retry Logic
# Fetches data for multiple Pokémon and saves to separate files
# Includes rate-limiting delay and retry mechanism (up to 3 attempts)

API_BASE_URL="https://pokeapi.co/api/v2/pokemon"
OUTPUT_DIR="pokemon_data"
ERROR_FILE="errors.txt"
DELAY=1  # Delay in seconds between requests
MAX_RETRIES=3  # Maximum number of retry attempts
RETRY_DELAY=2  # Delay in seconds before retrying

# List of Pokémon to fetch
POKEMON_LIST=("bulbasaur" "ivysaur" "venusaur" "charmander" "charmeleon")

# Create output directory if it doesn't exist
mkdir -p "$OUTPUT_DIR"

# Function to fetch Pokémon data with retry logic
fetch_pokemon() {
    local pokemon="$1"
    local attempt=1
    
    while [ $attempt -le $MAX_RETRIES ]; do
        # Make API request and capture HTTP status code
        HTTP_RESPONSE=$(curl -s -w "\n%{http_code}" --connect-timeout 10 --max-time 30 "$API_BASE_URL/$pokemon" 2>&1)
        
        # Check if curl command succeeded
        if [ $? -ne 0 ]; then
            echo "Network error on attempt $attempt/$MAX_RETRIES for $pokemon"
            if [ $attempt -lt $MAX_RETRIES ]; then
                echo "Retrying in $RETRY_DELAY seconds..."
                sleep $RETRY_DELAY
                ((attempt++))
                continue
            else
                TIMESTAMP=$(date '+%Y-%m-%d %H:%M:%S')
                echo "[$TIMESTAMP] Error: Network failure after $MAX_RETRIES attempts for $pokemon" >> "$ERROR_FILE"
                return 1
            fi
        fi
        
        # Extract HTTP status code (last line)
        HTTP_CODE=$(echo "$HTTP_RESPONSE" | tail -n 1)
        
        # Extract response body (everything except last line)
        RESPONSE_BODY=$(echo "$HTTP_RESPONSE" | sed '$d')
        
        # Check if request was successful (HTTP 200)
        if [ "$HTTP_CODE" -eq 200 ]; then
            OUTPUT_FILE="$OUTPUT_DIR/${pokemon}.json"
            echo "$RESPONSE_BODY" > "$OUTPUT_FILE"
            echo "Saved data to $OUTPUT_FILE"
            return 0
        elif [ "$HTTP_CODE" -eq 404 ]; then
            # Invalid Pokémon name - don't retry
            TIMESTAMP=$(date '+%Y-%m-%d %H:%M:%S')
            echo "[$TIMESTAMP] Error: HTTP 404 - Invalid Pokémon name: $pokemon" >> "$ERROR_FILE"
            echo "Error: Invalid Pokémon name '$pokemon' (HTTP 404)"
            return 1
        else
            # Other HTTP errors - retry
            echo "HTTP $HTTP_CODE error on attempt $attempt/$MAX_RETRIES for $pokemon"
            if [ $attempt -lt $MAX_RETRIES ]; then
                echo "Retrying in $RETRY_DELAY seconds..."
                sleep $RETRY_DELAY
                ((attempt++))
                continue
            else
                TIMESTAMP=$(date '+%Y-%m-%d %H:%M:%S')
                echo "[$TIMESTAMP] Error: HTTP $HTTP_CODE after $MAX_RETRIES attempts for $pokemon" >> "$ERROR_FILE"
                echo "Error: Request failed with HTTP code $HTTP_CODE for $pokemon after $MAX_RETRIES attempts"
                return 1
            fi
        fi
    done
}

# Loop through each Pokémon
for pokemon in "${POKEMON_LIST[@]}"; do
    echo "Fetching data for $pokemon..."
    
    # Convert to lowercase for API request
    pokemon_lower=$(echo "$pokemon" | tr '[:upper:]' '[:lower:]')
    
    # Fetch Pokémon data with retry logic
    fetch_pokemon "$pokemon_lower"
    
    # Add delay between requests to avoid rate-limiting
    # Skip delay after the last Pokémon
    if [ "$pokemon" != "${POKEMON_LIST[-1]}" ]; then
        sleep "$DELAY"
    fi
done
